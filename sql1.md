######SQL注入学习总结(一):SQL注入的分类


###1.按照执行效果分类

1. 基于布尔盲注,即只会回显true跟false,会根据你的注入信息返回true or false,也就没有了之前的报错信息(substr(),mid(),ascii())
   
2. 基于报错的注入,即页面会返回错误的信息,或者把注入的语句的结果直接返回在页面中(updatexml(),floor(),rand(0)\*2)

3. 基于时间的盲注,即界面值只有一种,无论输入任何值,返回情况都会按照正常的来处理,而加入特定的时间函数,通过看返回的页面时间差来判断注入的语句是否正确.(sleep().benchmark())

4. 堆查询注入,即以逗号分开的多条查询语句同时执行,但一般只返回第一条语句的查询结果,所以在第二条语句中进行注入时一般通过时间盲注来获取数据,有些数据库可以执行(pdo),有些不行

5. 回显注入,一般是可以使用union的情况下进行注入

***

###2.按照注入点的类型来分类:

1. 数字型(select * from 表名 where id=x),一般的判断语句
	`x and 1=1`页面正常运行,继续进行下一步(x已确认存在数据)
	`x and 1=2`页面出错,说明该注入为数字型注入
2. 字符型(select * from 表名 where id='x'),一般判断的语句:
	`x' and 1=1 %23或 x' and '1'='1`页面正常运行(#号也可能被过滤了导致不成功所以要多试)
	`x' and 1=2 %23或 x' and '1'='2`页面出错,说明该注入为字符型
3. 搜索型(再进行数据搜索的时候没有过滤参数 select * from 表名 where 字段 like '%keyword%')
	`x%' and '1'='1'%23`页面正常运行
	`x%' and '1'='2'%23`页面出错,说明为一个搜索型的sql注入
注:用or也可以进行判断的,不过他更多的用于绕过登录

***

###3.按照数据提交的方式

1. GET注入
2. POST注入
3. Cookie注入
4. XFF等一些需要补充参数的HTTP头部注入

***

